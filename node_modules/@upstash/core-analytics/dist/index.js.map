{"version":3,"sources":["../src/index.ts","../src/analytics.ts"],"sourcesContent":["export * from \"./analytics\";\n","import { Redis } from \"@upstash/redis\";\n\nexport type Event = {\n  time?: number;\n  [key: string]: string | number | boolean | undefined;\n};\n\nclass Key {\n  constructor(public readonly prefix: string, public readonly table: string, public readonly bucket: number) {}\n\n  public toString() {\n    return [this.prefix, this.table, this.bucket].join(\":\");\n  }\n  static fromString(key: string) {\n    const [prefix, table, bucket] = key.split(\":\");\n    return new Key(prefix, table, parseInt(bucket));\n  }\n}\n\nexport type Window = `${number}${\"s\" | \"m\" | \"h\" | \"d\"}`;\n\nexport type AnalyticsConfig = {\n  redis: Redis;\n  /**\n   * Configure the bucket size for analytics. All events inside the window will be stored inside\n   * the same bucket. This reduces the number of keys that need to be scanned when aggregating\n   * and reduces your cost.\n   *\n   * Must be either a string in the format of `1s`, `2m`, `3h`, `4d` or a number of milliseconds.\n   */\n  window: Window | number;\n  prefix?: string;\n\n  /**\n   * Configure the retention period for analytics. All events older than the retention period will\n   * be deleted. This reduces the number of keys that need to be scanned when aggregating.\n   *\n   * Can either be a string in the format of `1s`, `2m`, `3h`, `4d` or a number of milliseconds.\n   * 0, negative or undefined means that the retention is disabled.\n   *\n   * @default Disabled\n   *\n   * Buckets are evicted when they are read, not when they are written. This is much cheaper since\n   * it only requires a single command to ingest data.\n   */\n  retention?: Window | number;\n};\n\nclass Cache<TValue> {\n  private readonly cache: Map<string, { value: TValue; createdAt: number }>;\n  private readonly ttl: number;\n  constructor(ttl: number) {\n    this.cache = new Map();\n    this.ttl = ttl;\n\n    setInterval(() => {\n      const now = Date.now();\n      for (const [key, { createdAt }] of this.cache) {\n        if (now - createdAt > this.ttl) {\n          this.cache.delete(key);\n        }\n      }\n    }, this.ttl * 10);\n  }\n\n  public get(key: string): TValue | null {\n    const data = this.cache.get(key);\n    if (!data) {\n      return null;\n    }\n    if (Date.now() - data.createdAt > this.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n    return data.value;\n  }\n\n  public set(key: string, value: TValue) {\n    this.cache.set(key, { createdAt: Date.now(), value });\n  }\n}\n\nexport class Analytics {\n  private readonly redis: Redis;\n  private readonly prefix: string;\n  private readonly bucketSize: number;\n  private readonly retention?: number;\n\n  private readonly cache = new Cache<Record<string, number>>(60000);\n\n  constructor(config: AnalyticsConfig) {\n    this.redis = config.redis;\n    this.prefix = config.prefix ?? \"@upstash/analytics\";\n    this.bucketSize = this.parseWindow(config.window);\n    this.retention = config.retention ? this.parseWindow(config.retention) : undefined;\n  }\n\n  private validateTableName(table: string) {\n    const regex = /^[a-zA-Z0-9_-]+$/;\n    if (!regex.test(table)) {\n      throw new Error(\n        `Invalid table name: ${table}. Table names can only contain letters, numbers, dashes and underscores.`,\n      );\n    }\n  }\n\n  /**\n   * Parses the window string into a number of milliseconds\n   */\n  private parseWindow(window: Window | number): number {\n    if (typeof window === \"number\") {\n      if (window <= 0) {\n        throw new Error(`Invalid window: ${window}`);\n      }\n      return window;\n    }\n    const regex = /^(\\d+)([smhd])$/;\n    if (!regex.test(window)) {\n      throw new Error(`Invalid window: ${window}`);\n    }\n    const [, valueStr, unit] = window.match(regex)!;\n    const value = parseInt(valueStr);\n    switch (unit) {\n      case \"s\":\n        return value * 1000;\n      case \"m\":\n        return value * 1000 * 60;\n      case \"h\":\n        return value * 1000 * 60 * 60;\n      case \"d\":\n        return value * 1000 * 60 * 60 * 24;\n      default:\n        throw new Error(`Invalid window unit: ${unit}`);\n    }\n  }\n\n  /**\n   * Ingest a new event\n   * @param table\n   * @param event\n   */\n  public async ingest(table: string, ...events: Event[]): Promise<void> {\n    this.validateTableName(table);\n    await Promise.all(\n      events.map(async (event) => {\n        const time = event.time ?? Date.now();\n        // Bucket is a unix timestamp in milliseconds marking the beginning of a day\n        const bucket = Math.floor(time / this.bucketSize) * this.bucketSize;\n        const key = [this.prefix, table, bucket].join(\":\");\n\n        await this.redis.hincrby(\n          key,\n          JSON.stringify({\n            ...event,\n            time: undefined,\n          }),\n          1,\n        );\n      }),\n    );\n  }\n\n  private async loadBuckets(\n    table: string,\n    opts: {\n      scan?: boolean;\n      range: [number, number];\n    },\n  ): Promise<{ key: string; hash: Record<string, number> }[]> {\n    this.validateTableName(table);\n    const now = Date.now();\n\n    const keys: string[] = [];\n    if (opts.scan) {\n      let cursor = 0;\n      const match = [this.prefix, table, \"*\"].join(\":\");\n      do {\n        const [nextCursor, found] = await this.redis.scan(cursor, {\n          match,\n        });\n\n        cursor = nextCursor;\n        for (const key of found) {\n          const timestamp = parseInt(key.split(\":\").pop()!);\n          // Delete keys that are older than the retention period\n          if (this.retention && timestamp < now - this.retention) {\n            await this.redis.del(key);\n            continue;\n          }\n          // Take all the keys that at least overlap with the given range\n          if (timestamp >= opts.range[0] || timestamp <= opts.range[1]) {\n            keys.push(key);\n          }\n        }\n      } while (cursor !== 0);\n    } else {\n      let t = Math.floor(now / this.bucketSize) * this.bucketSize;\n      while (t > opts.range[1]) {\n        t -= this.bucketSize;\n      }\n      while (t >= opts.range[0]) {\n        keys.push([this.prefix, table, t].join(\":\"));\n        t -= this.bucketSize;\n      }\n    }\n    const loadKeys: string[] = [];\n    const buckets: { key: string; hash: Record<string, number> }[] = [];\n    for (const key of keys) {\n      const cached = this.cache.get(key);\n      if (cached) {\n        buckets.push({\n          key,\n          hash: cached,\n        });\n      } else {\n        loadKeys.push(key);\n      }\n    }\n\n    const p = this.redis.pipeline();\n    for (const key of loadKeys) {\n      p.hgetall(key);\n    }\n    const res = loadKeys.length > 0 ? await p.exec<(Record<string, number> | null)[]>() : [];\n    for (let i = 0; i < loadKeys.length; i++) {\n      const key = loadKeys[i];\n      const hash = res[i];\n      if (hash) {\n        this.cache.set(key, hash);\n      }\n      buckets.push({\n        key,\n        hash: hash ?? {},\n      });\n    }\n\n    return buckets.sort((a, b) => a.hash.time - b.hash.time);\n  }\n  /**\n   * Returns the number of events per bucket\n   */\n  async count(\n    table: string,\n    opts: {\n      range: [number, number];\n    },\n  ): Promise<{ time: number; count: number }[]> {\n    this.validateTableName(table);\n\n    const buckets = await this.loadBuckets(table, { range: opts.range });\n\n    return await Promise.all(\n      buckets.map(async ({ key, hash }) => {\n        const timestamp = parseInt(key.split(\":\").pop()!);\n        return {\n          time: timestamp,\n          count: Object.values(hash).reduce((acc, curr) => acc + curr, 0),\n        };\n      }),\n    );\n  }\n\n  /**\n   * Builds a timeseries of the aggreagated value\n   *\n   * @param aggregateBy - The field to aggregate by\n   * @param cutoff - Timestamp in milliseconds to limit the aggregation to `cutoff` until now\n   * @returns\n   */\n  async aggregateBy<TAggregateBy extends keyof Omit<Event, \"time\">>(\n    table: string,\n    aggregateBy: TAggregateBy,\n    opts: {\n      /**\n       * The range of timestamps to query. If not specified, all buckets are loaded.\n       * The range is inclusive.\n       * The first element is the start of the range, the second element is the end of the range.\n       *\n       * In milliseconds\n       */\n      range: [number, number];\n    },\n  ): Promise<({ time: number } & Record<string, Record<string, number>>)[]> {\n    this.validateTableName(table);\n\n    const buckets = await this.loadBuckets(table, { range: opts.range });\n\n    const days = await Promise.all(\n      buckets.map(async ({ key, hash }) => {\n        const day = { time: Key.fromString(key).bucket } as { time: number } & Record<\n          TAggregateBy,\n          Record<string, number>\n        >;\n\n        for (const [field, count] of Object.entries(hash)) {\n          const r = JSON.parse(field) as Record<TAggregateBy, unknown>;\n          for (const [k, v] of Object.entries(r) as [TAggregateBy, string][]) {\n\n            const agg = r[aggregateBy];\n            // @ts-ignore\n            if (!day[agg]) {\n              // @ts-ignore\n              day[agg] = {};\n            }\n            if (k === aggregateBy) {\n              continue;\n            }\n            // @ts-ignore\n            if (!day[agg][v]) {\n              // @ts-ignore\n              day[agg][v] = 0;\n            }\n            // @ts-ignore\n            day[agg][v] += count;\n          }\n        }\n        return day;\n      }),\n    );\n    return days;\n  }\n\n  async query<TWhere extends keyof Omit<Event, \"time\">, TFilter extends keyof Omit<Event, \"time\">>(\n    table: string,\n    opts: {\n      where?: Record<TWhere, unknown>;\n      filter?: TFilter[];\n      /**\n       * The range of timestamps to query.\n       * The range is inclusive.\n       * The first element is the start of the range, the second element is the end of the range.\n       *\n       * In milliseconds\n       */\n      range: [number, number];\n    },\n  ): Promise<{ time: number; [key: keyof Omit<Event, \"time\">]: number }[]> {\n    this.validateTableName(table);\n    const buckets = await this.loadBuckets(table, { range: opts.range });\n\n    const days = await Promise.all(\n      buckets.map(async ({ key, hash }) => {\n        const day = { time: Key.fromString(key).bucket } as { time: number } & {\n          [key: keyof Omit<Event, \"time\">]: Record<string, number>;\n        };\n\n        for (const [field, count] of Object.entries(hash)) {\n          const r = JSON.parse(field);\n\n          let skip = false;\n          if (opts?.where) {\n            for (const [requiredKey, requiredValue] of Object.entries(opts.where)) {\n              if (!(requiredKey in r)) {\n                skip = true;\n                break;\n              }\n              if (r[requiredKey] !== requiredValue) {\n                skip = true;\n                break;\n              }\n            }\n          }\n          if (skip) {\n            continue;\n          }\n          for (const [k, v] of Object.entries(r) as [string, string][]) {\n            // @ts-ignore\n            if (opts?.filter && !opts.filter.includes(k)) {\n              continue;\n            }\n            if (!day[k]) {\n              day[k] = {};\n            }\n            if (!day[k][v]) {\n              day[k][v] = 0;\n            }\n            day[k][v] += count;\n          }\n        }\n        return day;\n      }),\n    );\n    return days as any;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACOA,IAAM,MAAN,MAAU;AAAA,EACR,YAA4B,QAAgC,OAA+B,QAAgB;AAA/E;AAAgC;AAA+B;AAAA,EAAiB;AAAA,EAErG,WAAW;AAChB,WAAO,CAAC,KAAK,QAAQ,KAAK,OAAO,KAAK,MAAM,EAAE,KAAK,GAAG;AAAA,EACxD;AAAA,EACA,OAAO,WAAW,KAAa;AAC7B,UAAM,CAAC,QAAQ,OAAO,MAAM,IAAI,IAAI,MAAM,GAAG;AAC7C,WAAO,IAAI,IAAI,QAAQ,OAAO,SAAS,MAAM,CAAC;AAAA,EAChD;AACF;AA+BA,IAAM,QAAN,MAAoB;AAAA,EACD;AAAA,EACA;AAAA,EACjB,YAAY,KAAa;AACvB,SAAK,QAAQ,oBAAI,IAAI;AACrB,SAAK,MAAM;AAEX,gBAAY,MAAM;AAChB,YAAM,MAAM,KAAK,IAAI;AACrB,iBAAW,CAAC,KAAK,EAAE,UAAU,CAAC,KAAK,KAAK,OAAO;AAC7C,YAAI,MAAM,YAAY,KAAK,KAAK;AAC9B,eAAK,MAAM,OAAO,GAAG;AAAA,QACvB;AAAA,MACF;AAAA,IACF,GAAG,KAAK,MAAM,EAAE;AAAA,EAClB;AAAA,EAEO,IAAI,KAA4B;AACrC,UAAM,OAAO,KAAK,MAAM,IAAI,GAAG;AAC/B,QAAI,CAAC,MAAM;AACT,aAAO;AAAA,IACT;AACA,QAAI,KAAK,IAAI,IAAI,KAAK,YAAY,KAAK,KAAK;AAC1C,WAAK,MAAM,OAAO,GAAG;AACrB,aAAO;AAAA,IACT;AACA,WAAO,KAAK;AAAA,EACd;AAAA,EAEO,IAAI,KAAa,OAAe;AACrC,SAAK,MAAM,IAAI,KAAK,EAAE,WAAW,KAAK,IAAI,GAAG,MAAM,CAAC;AAAA,EACtD;AACF;AAEO,IAAM,YAAN,MAAgB;AAAA,EACJ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA,QAAQ,IAAI,MAA8B,GAAK;AAAA,EAEhE,YAAY,QAAyB;AACnC,SAAK,QAAQ,OAAO;AACpB,SAAK,SAAS,OAAO,UAAU;AAC/B,SAAK,aAAa,KAAK,YAAY,OAAO,MAAM;AAChD,SAAK,YAAY,OAAO,YAAY,KAAK,YAAY,OAAO,SAAS,IAAI;AAAA,EAC3E;AAAA,EAEQ,kBAAkB,OAAe;AACvC,UAAM,QAAQ;AACd,QAAI,CAAC,MAAM,KAAK,KAAK,GAAG;AACtB,YAAM,IAAI;AAAA,QACR,uBAAuB;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA,EAKQ,YAAY,QAAiC;AACnD,QAAI,OAAO,WAAW,UAAU;AAC9B,UAAI,UAAU,GAAG;AACf,cAAM,IAAI,MAAM,mBAAmB,QAAQ;AAAA,MAC7C;AACA,aAAO;AAAA,IACT;AACA,UAAM,QAAQ;AACd,QAAI,CAAC,MAAM,KAAK,MAAM,GAAG;AACvB,YAAM,IAAI,MAAM,mBAAmB,QAAQ;AAAA,IAC7C;AACA,UAAM,CAAC,EAAE,UAAU,IAAI,IAAI,OAAO,MAAM,KAAK;AAC7C,UAAM,QAAQ,SAAS,QAAQ;AAC/B,YAAQ,MAAM;AAAA,MACZ,KAAK;AACH,eAAO,QAAQ;AAAA,MACjB,KAAK;AACH,eAAO,QAAQ,MAAO;AAAA,MACxB,KAAK;AACH,eAAO,QAAQ,MAAO,KAAK;AAAA,MAC7B,KAAK;AACH,eAAO,QAAQ,MAAO,KAAK,KAAK;AAAA,MAClC;AACE,cAAM,IAAI,MAAM,wBAAwB,MAAM;AAAA,IAClD;AAAA,EACF;AAAA,EAOA,MAAa,OAAO,UAAkB,QAAgC;AACpE,SAAK,kBAAkB,KAAK;AAC5B,UAAM,QAAQ;AAAA,MACZ,OAAO,IAAI,OAAO,UAAU;AAC1B,cAAM,OAAO,MAAM,QAAQ,KAAK,IAAI;AAEpC,cAAM,SAAS,KAAK,MAAM,OAAO,KAAK,UAAU,IAAI,KAAK;AACzD,cAAM,MAAM,CAAC,KAAK,QAAQ,OAAO,MAAM,EAAE,KAAK,GAAG;AAEjD,cAAM,KAAK,MAAM;AAAA,UACf;AAAA,UACA,KAAK,UAAU;AAAA,YACb,GAAG;AAAA,YACH,MAAM;AAAA,UACR,CAAC;AAAA,UACD;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,MAAc,YACZ,OACA,MAI0D;AAC1D,SAAK,kBAAkB,KAAK;AAC5B,UAAM,MAAM,KAAK,IAAI;AAErB,UAAM,OAAiB,CAAC;AACxB,QAAI,KAAK,MAAM;AACb,UAAI,SAAS;AACb,YAAM,QAAQ,CAAC,KAAK,QAAQ,OAAO,GAAG,EAAE,KAAK,GAAG;AAChD,SAAG;AACD,cAAM,CAAC,YAAY,KAAK,IAAI,MAAM,KAAK,MAAM,KAAK,QAAQ;AAAA,UACxD;AAAA,QACF,CAAC;AAED,iBAAS;AACT,mBAAW,OAAO,OAAO;AACvB,gBAAM,YAAY,SAAS,IAAI,MAAM,GAAG,EAAE,IAAI,CAAE;AAEhD,cAAI,KAAK,aAAa,YAAY,MAAM,KAAK,WAAW;AACtD,kBAAM,KAAK,MAAM,IAAI,GAAG;AACxB;AAAA,UACF;AAEA,cAAI,aAAa,KAAK,MAAM,MAAM,aAAa,KAAK,MAAM,IAAI;AAC5D,iBAAK,KAAK,GAAG;AAAA,UACf;AAAA,QACF;AAAA,MACF,SAAS,WAAW;AAAA,IACtB,OAAO;AACL,UAAI,IAAI,KAAK,MAAM,MAAM,KAAK,UAAU,IAAI,KAAK;AACjD,aAAO,IAAI,KAAK,MAAM,IAAI;AACxB,aAAK,KAAK;AAAA,MACZ;AACA,aAAO,KAAK,KAAK,MAAM,IAAI;AACzB,aAAK,KAAK,CAAC,KAAK,QAAQ,OAAO,CAAC,EAAE,KAAK,GAAG,CAAC;AAC3C,aAAK,KAAK;AAAA,MACZ;AAAA,IACF;AACA,UAAM,WAAqB,CAAC;AAC5B,UAAM,UAA2D,CAAC;AAClE,eAAW,OAAO,MAAM;AACtB,YAAM,SAAS,KAAK,MAAM,IAAI,GAAG;AACjC,UAAI,QAAQ;AACV,gBAAQ,KAAK;AAAA,UACX;AAAA,UACA,MAAM;AAAA,QACR,CAAC;AAAA,MACH,OAAO;AACL,iBAAS,KAAK,GAAG;AAAA,MACnB;AAAA,IACF;AAEA,UAAM,IAAI,KAAK,MAAM,SAAS;AAC9B,eAAW,OAAO,UAAU;AAC1B,QAAE,QAAQ,GAAG;AAAA,IACf;AACA,UAAM,MAAM,SAAS,SAAS,IAAI,MAAM,EAAE,KAAwC,IAAI,CAAC;AACvF,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,YAAM,MAAM,SAAS;AACrB,YAAM,OAAO,IAAI;AACjB,UAAI,MAAM;AACR,aAAK,MAAM,IAAI,KAAK,IAAI;AAAA,MAC1B;AACA,cAAQ,KAAK;AAAA,QACX;AAAA,QACA,MAAM,QAAQ,CAAC;AAAA,MACjB,CAAC;AAAA,IACH;AAEA,WAAO,QAAQ,KAAK,CAAC,GAAG,MAAM,EAAE,KAAK,OAAO,EAAE,KAAK,IAAI;AAAA,EACzD;AAAA,EAIA,MAAM,MACJ,OACA,MAG4C;AAC5C,SAAK,kBAAkB,KAAK;AAE5B,UAAM,UAAU,MAAM,KAAK,YAAY,OAAO,EAAE,OAAO,KAAK,MAAM,CAAC;AAEnE,WAAO,MAAM,QAAQ;AAAA,MACnB,QAAQ,IAAI,OAAO,EAAE,KAAK,KAAK,MAAM;AACnC,cAAM,YAAY,SAAS,IAAI,MAAM,GAAG,EAAE,IAAI,CAAE;AAChD,eAAO;AAAA,UACL,MAAM;AAAA,UACN,OAAO,OAAO,OAAO,IAAI,EAAE,OAAO,CAAC,KAAK,SAAS,MAAM,MAAM,CAAC;AAAA,QAChE;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EASA,MAAM,YACJ,OACA,aACA,MAUwE;AACxE,SAAK,kBAAkB,KAAK;AAE5B,UAAM,UAAU,MAAM,KAAK,YAAY,OAAO,EAAE,OAAO,KAAK,MAAM,CAAC;AAEnE,UAAM,OAAO,MAAM,QAAQ;AAAA,MACzB,QAAQ,IAAI,OAAO,EAAE,KAAK,KAAK,MAAM;AACnC,cAAM,MAAM,EAAE,MAAM,IAAI,WAAW,GAAG,EAAE,OAAO;AAK/C,mBAAW,CAAC,OAAO,KAAK,KAAK,OAAO,QAAQ,IAAI,GAAG;AACjD,gBAAM,IAAI,KAAK,MAAM,KAAK;AAC1B,qBAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,CAAC,GAA+B;AAElE,kBAAM,MAAM,EAAE;AAEd,gBAAI,CAAC,IAAI,MAAM;AAEb,kBAAI,OAAO,CAAC;AAAA,YACd;AACA,gBAAI,MAAM,aAAa;AACrB;AAAA,YACF;AAEA,gBAAI,CAAC,IAAI,KAAK,IAAI;AAEhB,kBAAI,KAAK,KAAK;AAAA,YAChB;AAEA,gBAAI,KAAK,MAAM;AAAA,UACjB;AAAA,QACF;AACA,eAAO;AAAA,MACT,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,MACJ,OACA,MAYuE;AACvE,SAAK,kBAAkB,KAAK;AAC5B,UAAM,UAAU,MAAM,KAAK,YAAY,OAAO,EAAE,OAAO,KAAK,MAAM,CAAC;AAEnE,UAAM,OAAO,MAAM,QAAQ;AAAA,MACzB,QAAQ,IAAI,OAAO,EAAE,KAAK,KAAK,MAAM;AACnC,cAAM,MAAM,EAAE,MAAM,IAAI,WAAW,GAAG,EAAE,OAAO;AAI/C,mBAAW,CAAC,OAAO,KAAK,KAAK,OAAO,QAAQ,IAAI,GAAG;AACjD,gBAAM,IAAI,KAAK,MAAM,KAAK;AAE1B,cAAI,OAAO;AACX,cAAI,MAAM,OAAO;AACf,uBAAW,CAAC,aAAa,aAAa,KAAK,OAAO,QAAQ,KAAK,KAAK,GAAG;AACrE,kBAAI,EAAE,eAAe,IAAI;AACvB,uBAAO;AACP;AAAA,cACF;AACA,kBAAI,EAAE,iBAAiB,eAAe;AACpC,uBAAO;AACP;AAAA,cACF;AAAA,YACF;AAAA,UACF;AACA,cAAI,MAAM;AACR;AAAA,UACF;AACA,qBAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,CAAC,GAAyB;AAE5D,gBAAI,MAAM,UAAU,CAAC,KAAK,OAAO,SAAS,CAAC,GAAG;AAC5C;AAAA,YACF;AACA,gBAAI,CAAC,IAAI,IAAI;AACX,kBAAI,KAAK,CAAC;AAAA,YACZ;AACA,gBAAI,CAAC,IAAI,GAAG,IAAI;AACd,kBAAI,GAAG,KAAK;AAAA,YACd;AACA,gBAAI,GAAG,MAAM;AAAA,UACf;AAAA,QACF;AACA,eAAO;AAAA,MACT,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT;AACF;","names":[]}