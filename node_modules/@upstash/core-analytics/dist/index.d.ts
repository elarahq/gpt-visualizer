import { Redis } from '@upstash/redis';

type Event = {
    time?: number;
    [key: string]: string | number | boolean | undefined;
};
type Window = `${number}${"s" | "m" | "h" | "d"}`;
type AnalyticsConfig = {
    redis: Redis;
    /**
     * Configure the bucket size for analytics. All events inside the window will be stored inside
     * the same bucket. This reduces the number of keys that need to be scanned when aggregating
     * and reduces your cost.
     *
     * Must be either a string in the format of `1s`, `2m`, `3h`, `4d` or a number of milliseconds.
     */
    window: Window | number;
    prefix?: string;
    /**
     * Configure the retention period for analytics. All events older than the retention period will
     * be deleted. This reduces the number of keys that need to be scanned when aggregating.
     *
     * Can either be a string in the format of `1s`, `2m`, `3h`, `4d` or a number of milliseconds.
     * 0, negative or undefined means that the retention is disabled.
     *
     * @default Disabled
     *
     * Buckets are evicted when they are read, not when they are written. This is much cheaper since
     * it only requires a single command to ingest data.
     */
    retention?: Window | number;
};
declare class Analytics {
    private readonly redis;
    private readonly prefix;
    private readonly bucketSize;
    private readonly retention?;
    private readonly cache;
    constructor(config: AnalyticsConfig);
    private validateTableName;
    /**
     * Parses the window string into a number of milliseconds
     */
    private parseWindow;
    /**
     * Ingest a new event
     * @param table
     * @param event
     */
    ingest(table: string, ...events: Event[]): Promise<void>;
    private loadBuckets;
    /**
     * Returns the number of events per bucket
     */
    count(table: string, opts: {
        range: [number, number];
    }): Promise<{
        time: number;
        count: number;
    }[]>;
    /**
     * Builds a timeseries of the aggreagated value
     *
     * @param aggregateBy - The field to aggregate by
     * @param cutoff - Timestamp in milliseconds to limit the aggregation to `cutoff` until now
     * @returns
     */
    aggregateBy<TAggregateBy extends keyof Omit<Event, "time">>(table: string, aggregateBy: TAggregateBy, opts: {
        /**
         * The range of timestamps to query. If not specified, all buckets are loaded.
         * The range is inclusive.
         * The first element is the start of the range, the second element is the end of the range.
         *
         * In milliseconds
         */
        range: [number, number];
    }): Promise<({
        time: number;
    } & Record<string, Record<string, number>>)[]>;
    query<TWhere extends keyof Omit<Event, "time">, TFilter extends keyof Omit<Event, "time">>(table: string, opts: {
        where?: Record<TWhere, unknown>;
        filter?: TFilter[];
        /**
         * The range of timestamps to query.
         * The range is inclusive.
         * The first element is the start of the range, the second element is the end of the range.
         *
         * In milliseconds
         */
        range: [number, number];
    }): Promise<{
        time: number;
        [key: keyof Omit<Event, "time">]: number;
    }[]>;
}

export { Analytics, AnalyticsConfig, Event, Window };
